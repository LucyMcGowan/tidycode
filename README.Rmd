---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, echo = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "README-"
)
```

# tidycode

The goal of tidycode is to allow users to analyze R expressions in a tidy way.

## Installation

You can install tidycode from github with:

```{r gh-installation, eval = FALSE}
# install.packages("devtools")
devtools::install_github("LucyMcGowan/tidycode")
```

## Example

### Read in exisiting code

Using the matahari package, we can read in existing code, either as a string or a file, and turn it into a matahari tibble using `matahari::dance_recital()`.

```{r}
code <- "
library(broom)
library(glue)
m <- lm(mpg ~ am, data = mtcars)
t <- tidy(m)
glue_data(t, 'The point estimate for term {term} is {estimate}.')
"

m <- matahari::dance_recital(code)
```

Alternatively, you may already have a matahari tibble that was recorded during an R session.

Load the tidycode library.

```{r}
library(tidycode)
```

We can use the expressions from this matahari tibble to extract the names of the packages included.

```{r}
(pkg_names <- ls_packages(m$expr))
```

Use the `get_packages_tbl()` to create a tibble of all functions included in the packages that were used.

```{r}
(pkg_tbl <- get_packages_tbl(pkg_names))
```

Create a data frame of your expressions, splitting each into individual functions.

```{r}
u <- unnest_calls(m$expr)
```

Left join the package tibble to classify your functions by package name.

```{r}
u <- u %>%
  dplyr::left_join(pkg_tbl)
u
```

Add in the function classifications!

```{r}
classification_tbl <- get_classifications()
u %>%
  dplyr::left_join(classification_tbl)
```

