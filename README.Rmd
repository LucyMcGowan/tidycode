---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, echo = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "README-"
)
```

# tidycode

The goal of tidycode is to allow users to analyze R expressions in a tidy way.

## Installation

You can install tidycode from github with:

```{r gh-installation, eval = FALSE}
# install.packages("devtools")
devtools::install_github("LucyMcGowan/tidycode")
```

## Example

### Read in exisiting code

Using the matahari package, we can read in existing code, either as a string or a file, and turn it into a matahari tibble using `matahari::dance_recital()`.

```{r}
code <- "
library(broom)
library(glue)
m <- lm(mpg ~ am, data = mtcars)
t <- tidy(m)
glue_data(t, 'The point estimate for term {term} is {estimate}.')
"

m <- matahari::dance_recital(code)
```

Alternatively, you may already have a matahari tibble that was recorded during an R session.

Load the tidycode library.

```{r}
library(tidycode)
```

We can use the expressions from this matahari tibble to extract the names of the packages included.

```{r}
(pkg_names <- ls_packages(m$expr))
```

Use the `get_packages_tbl()` to create a tibble of all functions included in the packages that were used.

```{r}
(pkg_tbl <- get_packages_tbl(pkg_names))
```

Create a data frame of your expressions, splitting each into individual functions.

```{r}
u <- unnest_calls(m$expr)
```

Left join the package tibble to classify your functions by package name.

```{r}
u <- u %>%
  dplyr::left_join(pkg_tbl, c("names" = "func"))
u
```

Add in the function classifications!

```{r}
classification_tbl <- get_classification_tbl()
u %>%
  dplyr::left_join(classification_tbl, c("names" = "func"))
```



### Extract Plots and Models _(this may get deprecated, we are looking into new ways to label functions)_

Using the matahari package, we can capture R expressions that are called. For example, the following code will capture the two lines of R code, a plot and a model.

```{r}
library(tidycode)
```

```{r example}
matahari::dance_start()
plot(1:10)
m <- lm(mpg ~ cyl, mtcars)
matahari::dance_stop()
expr <- matahari::dance_tbl()$expr
```

Let's look at those expressions.
``` r
expr
#> [[1]]
#> sessionInfo()
#> 
#> [[2]]
#> matahari::dance_start()
#> 
#> [[3]]
#> plot(1:10)
#> 
#> [[4]]
#> m <- lm(mpg ~ cyl, mtcars)
#> 
#> [[5]]
#> sessionInfo()
```

We can check which expressions are plots using the `is_plot()` function.

``` r
is_plot(expr)
#> [1] FALSE FALSE  TRUE FALSE FALSE
```

We can check which expressions are calling modeling functions using the
`is_model()` function.

``` r
is_model(expr)
#> [1] FALSE FALSE FALSE  TRUE FALSE
```

Now letâ€™s clean up\!

``` r
matahari::dance_remove()
```

## Contributing

We are crowdsourcing the function classification. If you would like to contribute, you can fill out [this form](https://docs.google.com/forms/d/e/1FAIpQLSfyDIVPC3cgKfplS3O7n-lCjWDLIzpCzgV2ffYAhyFuJaUooA/viewform?usp=sf_link)!

Currently, the model and plot functions work by pulling in all functions from certain packages that are intended for modeling and plotting. To add more functions, update the files in the [`data-raw`](https://github.com/LucyMcGowan/tidycode/tree/master/data-raw) folder.
